- [1 模块化](#1-模块化)
  - [模块化发展历史](#模块化发展历史)
    - [探索](#探索)
      - [文件划分方式](#文件划分方式)
      - [命名空间方式](#命名空间方式)
      - [IIFE](#iife)
    - [规范出现](#规范出现)
      - [CommonJS](#commonjs)
      - [AMD](#amd)
      - [CMD](#cmd)
      - [ES Module](#es-module)
    - [最佳实践](#最佳实践)
  - [ES Module](#es-module-1)
    - [特性](#特性)
- [2 包管理工具](#2-包管理工具)
- [3 构建工具](#3-构建工具)
- [4 脚手架](#4-脚手架)


# 1 模块化

## 模块化发展历史

### 探索

#### 文件划分方式

约定每个 js 文件就是一个模块，每个模块通过 script 标签导入到 html 文件中

缺点：

- 每个模块没有私有空间，模块内的变量可以在外部被任意修改
- 容易出现命名冲突
- 无法管理模块之间的继承关系

#### 命名空间方式

每个 js 文件就是一个模块，并且将模块中的全部内容包裹成一个对象，再通过 script 标签导入到 html 文件中，通过 `module.method()` 的方式调用方法

优点：解决了模块之间的命名冲突问题

缺点：

- 每个模块没有私有空间，模块内的变量可以在外部被任意修改
- 无法管理模块之间的继承关系

#### IIFE

IIFE，Immediately Invoked Function Expression，立即调用函数表达式（匿名自执行函数），格式如下：

```
(function () {
  // …
})();
```

- 第一部分是一个具有词法作用域的匿名函数，并且用圆括号运算符 () 运算符闭合起来。这样不但阻止了外界访问自执行匿名函数中的变量，而且不会污染全局作用域。
- 第二部分创建了一个立即执行函数表达式 ()，通过它，JavaScript 引擎将立即执行该函数。

完整模块如下：

```
;(function () {
  var name = "module-a";

  function method1 () {
    // ...
  }

  function method2 () {
    // ...
  }

  window.moduleA = {
    method1: method1,
    method2: method2
  }
})();
```

可以发现，在匿名自执行函数之前有额外的分号，这是为了防止代码压缩时与前边的代码合并，并且，模块内除了定义属性和方法，还创建了一个全局对象 moduleA，将方法挂载到 window.moduleA 上，这样外界的方法无法对 name 进行访问，而模块内的方法可以通过闭包的方式访问到 name，从而实现了模块的私有空间

模块没有私有空间已经解决，那么如何明确依赖关系？

```
;(function ($) {
  var name = "module-a";

  function method1 () {
    $('body').animate({margin: '200px'})
  }

  function method2 () {
    // ...
  }

  window.moduleA = {
    method1: method1,
    method2: method2
  }
})(jQuery);
```

给这个匿名自执行函数设置一个 $ 参数，并且传入 jQuery，在函数内通过 $ 调用 jQuery 的方法，这样，每个模块的依赖关系就更明显了

### 规范出现

之前的模块化方式仍然存在问题：

- 每导入一个模块，就需要在 html 文件中创建一个 script 标签，项目规模变大后，维护困难

为了解决上述问题，出现了许多模块化规范，用于规定一个统一的标准，来实现便捷的 js 模块管理

#### CommonJS

特点：

- 一个文件就是一个模块
- 每个模块都有单独的作用域
- 通过 `module.exports` 导出成员
- 通过 require 函数载入模块

node.js 的模块规范，以同步方式加载模块，在启动时一次性加载所有模块，但是不适用于浏览器环境，因为每个页面加载时会加载大量的模块，影响加载速度

#### AMD

AMD，Asynchronous Module Definition，异步模块规范

Require.js 便实现了 AMD，虽然适用于浏览器环境，但是定义模块和载入模块的方式都比较复杂

#### CMD

CMD，Common Module Definition，常规模块规范

结合了 Require.js 和 CommonJS 的写法，让 AMD 的代码尽量和 CommonJS 相似，减少开发者学习成本，但之后被 Require.js 兼容...

#### ES Module

2015年，ES6 发布，随之而来的 ES Module 在语言层面原生实现了模块化，并随着 webpack 流行被广泛使用

### 最佳实践

浏览器 - ES Module（ES6）

node.js - CommonJS

## ES Module

### 特性

开启 ES Module ，为 script 添加 type 属性：

```
<script type="module"></script>
```

- 开启 ES module 后，自动开启严格模式，这样，全局 this 不再指向 window，而是 undefined
- 每个 ES module 都有单独的私有作用域
- ES module 的 script 标签获取外部 js 文件，是通过 CORS 方式获取的，这意味着，如果 js 文件不在同源地址，那么必须解决跨域问题

# 2 包管理工具

# 3 构建工具

# 4 脚手架